<call과 apply>
객체 안 메서드 안에 있는 함수는 this가 전역으로 바인딩 됨

this 바인딩 문제를 that 변수를 이용해서 해결을 함

this 값을 변경하기 위한 call(), apply() 메서드 (함수 안에서만 사용이 가능하다)
-call(), apply() 메서드는 함수.prototype 안에 정의되어있다

배열 메소드 중 sort()는 자동으로 내림차순 시켜줌
Array.prototype.sort.call(arguments,1,2,3)
: call() 이라는 메소드로 sort() 메소드를 사용할 수 있게 됨
: call() ->어디에 디스가 바인딩 될 것인가

Array.prototype.push.apply(arguments,["hello",123])

-->둘의 차이는 인자로 넣느냐, 배열로 넣느냐

맨 처음 생성된 함수.prototype 객체를 디폴트 프로토타입이라고 한다
함수.프로토타입을 변경하면 constructor 부분이 변경됨

<자바스크립트 엔진>

c언어에서 &은 주소

stack 영역 (지역 변수, 지역 함수, 매개변수 등) = Call Stack과 비슷한 개념
: 높은 주소에서 낮은 주소로 차곡차곡 쌓임

Call Stack에서 실행 context이자, 코드 블럭은 자바스크립트에서는 함수라고 생각하면 됨
즉, Call Stack은 코드가 하나하나씩 실행되는 공간

Call Stack이 실행 될 때
1. 전역 코드가 실행됐을 때
2. 함수 호출될 때 실행 컨텍스트에 함수가 쌓임

실행 컨텍스트>활성 객체
scope란 컨텍스트의 유효 범위, 유효 범위는 함수로 구분(단위가 함수), 
scope라는 걸 타고 다른 컨텍스트(list)에 접근할 수 있다
스코프는 프로토타입처럼 링크를 만든다 
컨텍스트를 만들어서 스코프 생성, 스코프 링크를 따라감

호이스팅이란, 변수 선언과 할당이 분리되는 현상
good();
function good() {
console.log(1); 
} --> 호이스팅으로 인해 오류 안 남
자바 스크립트 엔진이 변수 중 선언만 끌어올리기 때문이다
(컨텍스트 안에 함수와 변수가 정리가 안 되기 때문)
초기화 코드를 만나기 전까지 무조건 undefined

for(var a=1; a<5; a++){

}
--> 컨텍스트는 호이스팅으로 var a; for(a=1; ~)식으로 해석을 함

함수는 호출 시에만 컨텍스트에 올라간다